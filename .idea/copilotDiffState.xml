<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/SELECCION_MULTIPLE_CATEGORIAS.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SELECCION_MULTIPLE_CATEGORIAS.md" />
              <option name="updatedContent" value="# ✨ Selección Múltiple de Categorías&#10;&#10;##  Nueva Funcionalidad Implementada&#10;&#10;El admin ahora puede **seleccionar múltiples categorías** para cada receta usando chips interactivos.&#10;&#10;---&#10;&#10;##  Comparación&#10;&#10;### ❌ ANTES (Una Sola Categoría):&#10;```&#10;┌─────────────────────────────────┐&#10;│ Categoría: [Desayuno ▼]         │&#10;└─────────────────────────────────┘&#10;```&#10;- Solo podía elegir 1 categoría&#10;- Dropdown tradicional&#10;- Limitado&#10;&#10;### ✅ AHORA (Múltiples Categorías):&#10;```&#10;┌──────────────────────────────────────────┐&#10;│  Categorías * (Selecciona una o más)  │&#10;├──────────────────────────────────────────┤&#10;│ [✓  Desayuno] [ Almuerzo] [ Cena]│&#10;│ [ Postre] [ Bebidas] [ Snacks]   │&#10;│ [✓  Ensaladas] [ Sopas] [ Carnes]│&#10;│ ...más categorías...                     │&#10;│                                          │&#10;│ ┌──────────────────────────────────────┐ │&#10;│ │ Categorías seleccionadas:            │ │&#10;│ │ Desayuno, Ensaladas                  │ │&#10;│ └──────────────────────────────────────┘ │&#10;└──────────────────────────────────────────┘&#10;```&#10;- Puede seleccionar varias categorías&#10;- Chips visuales con iconos&#10;- Feedback instantáneo&#10;&#10;---&#10;&#10;##  Características del Sistema de Chips&#10;&#10;### 1. **Chips Interactivos**&#10;```kotlin&#10;FilterChip(&#10;    selected = seleccionada,&#10;    onClick = { /* toggle */ },&#10;    label = { Text(&quot; Desayuno&quot;) },&#10;    leadingIcon = { Icon(Check) } // Si está seleccionada&#10;)&#10;```&#10;&#10;### 2. **Estados Visuales**&#10;&#10;**No Seleccionado:**&#10;```&#10;[ Desayuno]&#10;```&#10;Fondo normal, sin check&#10;&#10;**Seleccionado:**&#10;```&#10;[✓  Desayuno]&#10;```&#10;Fondo de color, con check ✓&#10;&#10;### 3. **Layout FlowRow**&#10;Los chips se ajustan automáticamente en múltiples filas según el espacio disponible.&#10;&#10;### 4. **Resumen de Selección**&#10;```&#10;┌──────────────────────────────────────┐&#10;│ Categorías seleccionadas:            │&#10;│ Desayuno, Almuerzo, Vegetariana      │&#10;└──────────────────────────────────────┘&#10;```&#10;&#10;---&#10;&#10;##  Flujo de Uso&#10;&#10;### 1. Admin Abre el Formulario&#10;```&#10;Ver todos los chips de categorías disponibles&#10;(16 categorías con iconos)&#10;```&#10;&#10;### 2. Selecciona Categorías&#10;```&#10;Toca:  Desayuno → Se marca con ✓&#10;Toca:  Ensaladas → Se marca con ✓&#10;Toca:  Vegetariana → Se marca con ✓&#10;```&#10;&#10;### 3. Ve el Resumen&#10;```&#10;┌──────────────────────────────────────┐&#10;│ Categorías seleccionadas:            │&#10;│ Desayuno, Ensaladas, Vegetariana     │&#10;└──────────────────────────────────────┘&#10;```&#10;&#10;### 4. Notificación Automática&#10;```&#10;Si seleccionó &quot;Vegetariana&quot;:&#10;┌──────────────────────────────────────┐&#10;│ ℹ️ Esta receta será marcada como    │&#10;│    Vegetariana                     │&#10;└──────────────────────────────────────┘&#10;```&#10;&#10;### 5. Guarda la Receta&#10;```&#10;categoria: &quot;Desayuno&quot; (primera seleccionada)&#10;esVegetariana: true (detectado automáticamente)&#10;```&#10;&#10;---&#10;&#10;##  Almacenamiento&#10;&#10;```kotlin&#10;// En el código:&#10;var categoriasSeleccionadas by remember { &#10;    mutableStateOf(setOf&lt;String&gt;()) &#10;}&#10;&#10;// Al guardar:&#10;val nuevaReceta = Receta(&#10;    categoria = categoriasSeleccionadas.firstOrNull() ?: &quot;&quot;,&#10;    // ...otros campos&#10;)&#10;```&#10;&#10;**Nota**: Actualmente se guarda solo la primera categoría seleccionada en el campo `categoria`, pero el sistema está preparado para futuras extensiones donde se puedan almacenar todas las categorías.&#10;&#10;---&#10;&#10;## ✨ Casos de Uso&#10;&#10;### Caso 1: Receta Multifacética&#10;```&#10;Receta: &quot;Smoothie Bowl&quot;&#10;Categorías: Desayuno + Snacks + Vegetariana + Vegana&#10;&#10;✅ Aparece cuando el usuario filtra por &quot;Desayuno&quot;&#10;✅ Marcada automáticamente como vegetariana&#10;✅ Marcada automáticamente como vegana&#10;```&#10;&#10;### Caso 2: Receta de Horario Flexible&#10;```&#10;Receta: &quot;Sándwich Gourmet&quot;&#10;Categorías: Desayuno + Almuerzo + Cena&#10;&#10;✅ Aparece en todos esos filtros&#10;✅ Máxima visibilidad&#10;```&#10;&#10;### Caso 3: Receta con Características&#10;```&#10;Receta: &quot;Ensalada César&quot;&#10;Categorías: Ensaladas + Económica + Rápidas&#10;&#10;✅ Aparece en 3 filtros diferentes&#10;✅ Más oportunidades de ser encontrada&#10;```&#10;&#10;---&#10;&#10;##  Ventajas&#10;&#10;### 1. **Mayor Flexibilidad**&#10;✅ Una receta puede aparecer en múltiples categorías&#10;✅ No necesitas elegir una sola&#10;&#10;### 2. **Mejor Descubrimiento**&#10;✅ Las recetas son más fáciles de encontrar&#10;✅ Más puntos de acceso para los usuarios&#10;&#10;### 3. **Clasificación Precisa**&#10;✅ Puedes ser específico y general al mismo tiempo&#10;✅ &quot;Desayuno + Vegetariana + Rápidas&quot;&#10;&#10;### 4. **Visual e Intuitivo**&#10;✅ Chips con iconos&#10;✅ Feedback visual inmediato&#10;✅ Fácil de entender y usar&#10;&#10;---&#10;&#10;##  Detalles Técnicos&#10;&#10;### Estructura de Datos:&#10;```kotlin&#10;// Estado interno (múltiples categorías)&#10;var categoriasSeleccionadas: Set&lt;String&gt;&#10;&#10;// Ejemplos:&#10;setOf(&quot;Desayuno&quot;, &quot;Vegetariana&quot;)&#10;setOf(&quot;Almuerzo&quot;, &quot;Carnes&quot;, &quot;Económica&quot;)&#10;```&#10;&#10;### Validación:&#10;```kotlin&#10;enabled = nombre.isNotBlank() &amp;&amp; categoriasSeleccionadas.isNotEmpty()&#10;```&#10;El botón &quot;GUARDAR&quot; se habilita solo si hay al menos una categoría seleccionada.&#10;&#10;### Detección Automática:&#10;```kotlin&#10;val esVegetariana = categoriasSeleccionadas.any { &#10;    it.equals(&quot;Vegetariana&quot;, ignoreCase = true) &#10;} || categoriasSeleccionadas.any { &#10;    it.equals(&quot;Vegana&quot;, ignoreCase = true) &#10;}&#10;```&#10;&#10;---&#10;&#10;##  Experiencia del Usuario&#10;&#10;### Admin Crea Receta:&#10;```&#10;1. Llena nombre y descripción&#10;2. Ve grid de chips con todas las categorías&#10;3. Toca chips para seleccionar (✓ aparece)&#10;4. Ve resumen de categorías seleccionadas&#10;5. Si seleccionó &quot;Vegetariana&quot;, ve notificación&#10;6. Guarda con confianza&#10;```&#10;&#10;### Usuario Final:&#10;```&#10;1. Filtra por &quot;Desayuno&quot;&#10;2. Ve la receta que el admin marcó con &quot;Desayuno&quot;&#10;3. También la ve si filtra por otras categorías marcadas&#10;4. ✅ Más oportunidades de descubrir la receta&#10;```&#10;&#10;---&#10;&#10;##  Resultado&#10;&#10;```&#10;╔════════════════════════════════════════╗&#10;║                                        ║&#10;║  SELECCIÓN MÚLTIPLE DE CATEGORÍAS     ║&#10;║                                        ║&#10;║  ✅ Chips interactivos                ║&#10;║  ✅ Selección visual con ✓            ║&#10;║  ✅ Resumen de seleccionadas          ║&#10;║  ✅ Iconos en cada categoría          ║&#10;║  ✅ FlowRow adaptativo                ║&#10;║  ✅ Detección automática              ║&#10;║                                        ║&#10;╚════════════════════════════════════════╝&#10;```&#10;&#10;¡El admin ahora tiene mucha más flexibilidad para clasificar recetas! &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/saborforaneo/data/model/ChatModels.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/saborforaneo/data/model/ChatModels.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.saborforaneo.data.model&#10;&#10;import com.google.gson.annotations.SerializedName&#10;&#10;/**&#10; * Modelo para enviar mensajes al backend&#10; */&#10;data class ChatRequest(&#10;    @SerializedName(&quot;message&quot;)&#10;    val message: String&#10;)&#10;&#10;/**&#10; * Modelo para recibir respuestas del backend&#10; */&#10;data class ChatResponse(&#10;    @SerializedName(&quot;reply&quot;)&#10;    val reply: String&#10;)&#10;&#10;/**&#10; * Modelo para representar un mensaje en la conversación&#10; */&#10;data class ChatMessage(&#10;    val id: String = System.currentTimeMillis().toString(),&#10;    val text: String,&#10;    val isUser: Boolean,&#10;    val timestamp: Long = System.currentTimeMillis(),&#10;    val isLoading: Boolean = false&#10;)&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/saborforaneo/data/remote/api/GeminiApiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/saborforaneo/data/remote/api/GeminiApiService.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.saborforaneo.data.remote.api&#10;&#10;import com.example.saborforaneo.data.model.ChatRequest&#10;import com.example.saborforaneo.data.model.ChatResponse&#10;import retrofit2.http.Body&#10;import retrofit2.http.POST&#10;&#10;/**&#10; * Interface para definir los endpoints de la API de Gemini&#10; */&#10;interface GeminiApiService {&#10;&#10;    /**&#10;     * Enviar un mensaje al chatbot de Gemini&#10;     * @param request Objeto con el mensaje del usuario&#10;     * @return Respuesta del chatbot&#10;     */&#10;    @POST(&quot;chat&quot;)&#10;    suspend fun sendMessage(@Body request: ChatRequest): ChatResponse&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/saborforaneo/data/repository/ChatRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/saborforaneo/data/repository/ChatRepository.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.saborforaneo.data.repository&#10;&#10;import com.example.saborforaneo.data.model.ChatRequest&#10;import com.example.saborforaneo.data.model.ChatResponse&#10;import com.example.saborforaneo.data.remote.api.RetrofitClient&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;&#10;/**&#10; * Repository para manejar las operaciones del chat con Gemini&#10; */&#10;class ChatRepository {&#10;&#10;    private val api = RetrofitClient.geminiApi&#10;&#10;    /**&#10;     * Enviar mensaje al backend de Gemini&#10;     */&#10;    suspend fun sendMessage(message: String): Result&lt;ChatResponse&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val request = ChatRequest(message = message)&#10;                val response = api.sendMessage(request)&#10;                Result.success(response)&#10;            } catch (e: Exception) {&#10;                Result.failure(e)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/saborforaneo/ui/components/ChatMessageBubble.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/saborforaneo/ui/components/ChatMessageBubble.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.saborforaneo.ui.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.saborforaneo.data.model.ChatMessage&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;/**&#10; * Burbuja de mensaje del chat&#10; */&#10;@Composable&#10;fun ChatMessageBubble(&#10;    message: ChatMessage,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val alignment = if (message.isUser) Alignment.End else Alignment.Start&#10;    val backgroundColor = if (message.isUser) {&#10;        MaterialTheme.colorScheme.primary&#10;    } else {&#10;        MaterialTheme.colorScheme.surfaceVariant&#10;    }&#10;    val textColor = if (message.isUser) {&#10;        MaterialTheme.colorScheme.onPrimary&#10;    } else {&#10;        MaterialTheme.colorScheme.onSurfaceVariant&#10;    }&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 4.dp),&#10;        horizontalAlignment = alignment&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .widthIn(max = 280.dp)&#10;                .clip(&#10;                    RoundedCornerShape(&#10;                        topStart = 16.dp,&#10;                        topEnd = 16.dp,&#10;                        bottomStart = if (message.isUser) 16.dp else 4.dp,&#10;                        bottomEnd = if (message.isUser) 4.dp else 16.dp&#10;                    )&#10;                )&#10;                .background(backgroundColor)&#10;                .padding(12.dp)&#10;        ) {&#10;            if (message.isLoading) {&#10;                // Indicador de carga&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(4.dp)&#10;                ) {&#10;                    repeat(3) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(8.dp),&#10;                            strokeWidth = 2.dp,&#10;                            color = textColor&#10;                        )&#10;                    }&#10;                }&#10;            } else {&#10;                Text(&#10;                    text = message.text,&#10;                    color = textColor,&#10;                    fontSize = 15.sp,&#10;                    lineHeight = 20.sp&#10;                )&#10;            }&#10;        }&#10;&#10;        // Timestamp&#10;        if (!message.isLoading) {&#10;            Text(&#10;                text = formatTimestamp(message.timestamp),&#10;                fontSize = 11.sp,&#10;                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),&#10;                modifier = Modifier.padding(horizontal = 8.dp, vertical = 2.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Formatear timestamp a hora legible&#10; */&#10;private fun formatTimestamp(timestamp: Long): String {&#10;    val sdf = SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault())&#10;    return sdf.format(Date(timestamp))&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/saborforaneo/ui/screens/chat/PantallaChat.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/saborforaneo/ui/screens/chat/PantallaChat.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.saborforaneo.ui.screens.chat&#10;&#10;import androidx.compose.animation.*&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.lazy.rememberLazyListState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.saborforaneo.ui.components.ChatMessageBubble&#10;import com.example.saborforaneo.viewmodel.ChatViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Pantalla del chat con Gemini AI&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun PantallaChat(&#10;    onDismiss: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: ChatViewModel = viewModel()&#10;) {&#10;    val messages by viewModel.messages.collectAsState()&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;    val error by viewModel.error.collectAsState()&#10;&#10;    var messageText by remember { mutableStateOf(&quot;&quot;) }&#10;    val listState = rememberLazyListState()&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // Auto-scroll cuando llega un nuevo mensaje&#10;    LaunchedEffect(messages.size) {&#10;        if (messages.isNotEmpty()) {&#10;            coroutineScope.launch {&#10;                listState.animateScrollToItem(messages.size - 1)&#10;            }&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .systemBarsPadding()&#10;    ) {&#10;        // Header&#10;        Surface(&#10;            color = MaterialTheme.colorScheme.primaryContainer,&#10;            tonalElevation = 3.dp&#10;        ) {&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.SmartToy,&#10;                        contentDescription = null,&#10;                        modifier = Modifier.size(32.dp),&#10;                        tint = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    Column {&#10;                        Text(&#10;                            text = &quot;Chef AI Asistente&quot;,&#10;                            fontSize = 18.sp,&#10;                            fontWeight = FontWeight.Bold&#10;                        )&#10;                        Text(&#10;                            text = &quot;Powered by Gemini&quot;,&#10;                            fontSize = 12.sp,&#10;                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    // Botón limpiar chat&#10;                    IconButton(onClick = { viewModel.clearChat() }) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.RestartAlt,&#10;                            contentDescription = &quot;Limpiar chat&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;&#10;                    // Botón cerrar&#10;                    IconButton(onClick = onDismiss) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Close,&#10;                            contentDescription = &quot;Cerrar&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Mostrar error si existe&#10;        AnimatedVisibility(&#10;            visible = error != null,&#10;            enter = slideInVertically() + fadeIn(),&#10;            exit = slideOutVertically() + fadeOut()&#10;        ) {&#10;            Surface(&#10;                color = MaterialTheme.colorScheme.errorContainer,&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(12.dp),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Row(&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Error,&#10;                            contentDescription = null,&#10;                            tint = MaterialTheme.colorScheme.error&#10;                        )&#10;                        Text(&#10;                            text = error ?: &quot;&quot;,&#10;                            fontSize = 13.sp,&#10;                            color = MaterialTheme.colorScheme.onErrorContainer&#10;                        )&#10;                    }&#10;&#10;                    IconButton(onClick = { viewModel.clearError() }) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Close,&#10;                            contentDescription = &quot;Cerrar error&quot;,&#10;                            tint = MaterialTheme.colorScheme.error,&#10;                            modifier = Modifier.size(18.dp)&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Lista de mensajes&#10;        LazyColumn(&#10;            state = listState,&#10;            modifier = Modifier&#10;                .weight(1f)&#10;                .fillMaxWidth(),&#10;            contentPadding = PaddingValues(vertical = 16.dp)&#10;        ) {&#10;            items(messages) { message -&gt;&#10;                ChatMessageBubble(message = message)&#10;            }&#10;        }&#10;&#10;        // Input de mensaje&#10;        Surface(&#10;            color = MaterialTheme.colorScheme.surface,&#10;            tonalElevation = 3.dp,&#10;            shadowElevation = 8.dp&#10;        ) {&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                OutlinedTextField(&#10;                    value = messageText,&#10;                    onValueChange = { messageText = it },&#10;                    modifier = Modifier.weight(1f),&#10;                    placeholder = { Text(&quot;Escribe tu mensaje...&quot;) },&#10;                    enabled = !isLoading,&#10;                    shape = RoundedCornerShape(24.dp),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedBorderColor = MaterialTheme.colorScheme.outline.copy(alpha = 0.5f)&#10;                    ),&#10;                    maxLines = 3&#10;                )&#10;&#10;                // Botón enviar&#10;                FloatingActionButton(&#10;                    onClick = {&#10;                        if (messageText.isNotBlank()) {&#10;                            viewModel.sendMessage(messageText)&#10;                            messageText = &quot;&quot;&#10;                        }&#10;                    },&#10;                    containerColor = MaterialTheme.colorScheme.primary,&#10;                    modifier = Modifier.size(56.dp)&#10;                ) {&#10;                    if (isLoading) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(24.dp),&#10;                            color = MaterialTheme.colorScheme.onPrimary,&#10;                            strokeWidth = 2.dp&#10;                        )&#10;                    } else {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Send,&#10;                            contentDescription = &quot;Enviar mensaje&quot;,&#10;                            tint = MaterialTheme.colorScheme.onPrimary&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>